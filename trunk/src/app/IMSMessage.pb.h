// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IMSMessage.proto

#ifndef PROTOBUF_IMSMessage_2eproto__INCLUDED
#define PROTOBUF_IMSMessage_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_IMSMessage_2eproto();
void protobuf_AssignDesc_IMSMessage_2eproto();
void protobuf_ShutdownFile_IMSMessage_2eproto();

class AddStreamMsg;
class DelStreamMsg;
class IMSMessage;
class NumClientsReplyMsg;
class StreamClientsCount;
class StreamEndMsg;

// ===================================================================

class AddStreamMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:AddStreamMsg) */ {
 public:
  AddStreamMsg();
  virtual ~AddStreamMsg();

  AddStreamMsg(const AddStreamMsg& from);

  inline AddStreamMsg& operator=(const AddStreamMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AddStreamMsg& default_instance();

  void Swap(AddStreamMsg* other);

  // implements Message ----------------------------------------------

  inline AddStreamMsg* New() const { return New(NULL); }

  AddStreamMsg* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddStreamMsg& from);
  void MergeFrom(const AddStreamMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AddStreamMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string streamId = 1;
  bool has_streamid() const;
  void clear_streamid();
  static const int kStreamIdFieldNumber = 1;
  const ::std::string& streamid() const;
  void set_streamid(const ::std::string& value);
  void set_streamid(const char* value);
  void set_streamid(const char* value, size_t size);
  ::std::string* mutable_streamid();
  ::std::string* release_streamid();
  void set_allocated_streamid(::std::string* streamid);

  // repeated string rtmpSinkIP = 2;
  int rtmpsinkip_size() const;
  void clear_rtmpsinkip();
  static const int kRtmpSinkIPFieldNumber = 2;
  const ::std::string& rtmpsinkip(int index) const;
  ::std::string* mutable_rtmpsinkip(int index);
  void set_rtmpsinkip(int index, const ::std::string& value);
  void set_rtmpsinkip(int index, const char* value);
  void set_rtmpsinkip(int index, const char* value, size_t size);
  ::std::string* add_rtmpsinkip();
  void add_rtmpsinkip(const ::std::string& value);
  void add_rtmpsinkip(const char* value);
  void add_rtmpsinkip(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& rtmpsinkip() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_rtmpsinkip();

  // @@protoc_insertion_point(class_scope:AddStreamMsg)
 private:
  inline void set_has_streamid();
  inline void clear_has_streamid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr streamid_;
  ::google::protobuf::RepeatedPtrField< ::std::string> rtmpsinkip_;
  friend void  protobuf_AddDesc_IMSMessage_2eproto();
  friend void protobuf_AssignDesc_IMSMessage_2eproto();
  friend void protobuf_ShutdownFile_IMSMessage_2eproto();

  void InitAsDefaultInstance();
  static AddStreamMsg* default_instance_;
};
// -------------------------------------------------------------------

class DelStreamMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DelStreamMsg) */ {
 public:
  DelStreamMsg();
  virtual ~DelStreamMsg();

  DelStreamMsg(const DelStreamMsg& from);

  inline DelStreamMsg& operator=(const DelStreamMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DelStreamMsg& default_instance();

  void Swap(DelStreamMsg* other);

  // implements Message ----------------------------------------------

  inline DelStreamMsg* New() const { return New(NULL); }

  DelStreamMsg* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DelStreamMsg& from);
  void MergeFrom(const DelStreamMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DelStreamMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string streamId = 1;
  bool has_streamid() const;
  void clear_streamid();
  static const int kStreamIdFieldNumber = 1;
  const ::std::string& streamid() const;
  void set_streamid(const ::std::string& value);
  void set_streamid(const char* value);
  void set_streamid(const char* value, size_t size);
  ::std::string* mutable_streamid();
  ::std::string* release_streamid();
  void set_allocated_streamid(::std::string* streamid);

  // @@protoc_insertion_point(class_scope:DelStreamMsg)
 private:
  inline void set_has_streamid();
  inline void clear_has_streamid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr streamid_;
  friend void  protobuf_AddDesc_IMSMessage_2eproto();
  friend void protobuf_AssignDesc_IMSMessage_2eproto();
  friend void protobuf_ShutdownFile_IMSMessage_2eproto();

  void InitAsDefaultInstance();
  static DelStreamMsg* default_instance_;
};
// -------------------------------------------------------------------

class StreamEndMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:StreamEndMsg) */ {
 public:
  StreamEndMsg();
  virtual ~StreamEndMsg();

  StreamEndMsg(const StreamEndMsg& from);

  inline StreamEndMsg& operator=(const StreamEndMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StreamEndMsg& default_instance();

  void Swap(StreamEndMsg* other);

  // implements Message ----------------------------------------------

  inline StreamEndMsg* New() const { return New(NULL); }

  StreamEndMsg* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StreamEndMsg& from);
  void MergeFrom(const StreamEndMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StreamEndMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string streamId = 1;
  bool has_streamid() const;
  void clear_streamid();
  static const int kStreamIdFieldNumber = 1;
  const ::std::string& streamid() const;
  void set_streamid(const ::std::string& value);
  void set_streamid(const char* value);
  void set_streamid(const char* value, size_t size);
  ::std::string* mutable_streamid();
  ::std::string* release_streamid();
  void set_allocated_streamid(::std::string* streamid);

  // optional string rtmpSinkIP = 2;
  bool has_rtmpsinkip() const;
  void clear_rtmpsinkip();
  static const int kRtmpSinkIPFieldNumber = 2;
  const ::std::string& rtmpsinkip() const;
  void set_rtmpsinkip(const ::std::string& value);
  void set_rtmpsinkip(const char* value);
  void set_rtmpsinkip(const char* value, size_t size);
  ::std::string* mutable_rtmpsinkip();
  ::std::string* release_rtmpsinkip();
  void set_allocated_rtmpsinkip(::std::string* rtmpsinkip);

  // @@protoc_insertion_point(class_scope:StreamEndMsg)
 private:
  inline void set_has_streamid();
  inline void clear_has_streamid();
  inline void set_has_rtmpsinkip();
  inline void clear_has_rtmpsinkip();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr streamid_;
  ::google::protobuf::internal::ArenaStringPtr rtmpsinkip_;
  friend void  protobuf_AddDesc_IMSMessage_2eproto();
  friend void protobuf_AssignDesc_IMSMessage_2eproto();
  friend void protobuf_ShutdownFile_IMSMessage_2eproto();

  void InitAsDefaultInstance();
  static StreamEndMsg* default_instance_;
};
// -------------------------------------------------------------------

class StreamClientsCount : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:StreamClientsCount) */ {
 public:
  StreamClientsCount();
  virtual ~StreamClientsCount();

  StreamClientsCount(const StreamClientsCount& from);

  inline StreamClientsCount& operator=(const StreamClientsCount& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StreamClientsCount& default_instance();

  void Swap(StreamClientsCount* other);

  // implements Message ----------------------------------------------

  inline StreamClientsCount* New() const { return New(NULL); }

  StreamClientsCount* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StreamClientsCount& from);
  void MergeFrom(const StreamClientsCount& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StreamClientsCount* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string streamId = 1;
  bool has_streamid() const;
  void clear_streamid();
  static const int kStreamIdFieldNumber = 1;
  const ::std::string& streamid() const;
  void set_streamid(const ::std::string& value);
  void set_streamid(const char* value);
  void set_streamid(const char* value, size_t size);
  ::std::string* mutable_streamid();
  ::std::string* release_streamid();
  void set_allocated_streamid(::std::string* streamid);

  // optional int32 numClients = 2;
  bool has_numclients() const;
  void clear_numclients();
  static const int kNumClientsFieldNumber = 2;
  ::google::protobuf::int32 numclients() const;
  void set_numclients(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:StreamClientsCount)
 private:
  inline void set_has_streamid();
  inline void clear_has_streamid();
  inline void set_has_numclients();
  inline void clear_has_numclients();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr streamid_;
  ::google::protobuf::int32 numclients_;
  friend void  protobuf_AddDesc_IMSMessage_2eproto();
  friend void protobuf_AssignDesc_IMSMessage_2eproto();
  friend void protobuf_ShutdownFile_IMSMessage_2eproto();

  void InitAsDefaultInstance();
  static StreamClientsCount* default_instance_;
};
// -------------------------------------------------------------------

class NumClientsReplyMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NumClientsReplyMsg) */ {
 public:
  NumClientsReplyMsg();
  virtual ~NumClientsReplyMsg();

  NumClientsReplyMsg(const NumClientsReplyMsg& from);

  inline NumClientsReplyMsg& operator=(const NumClientsReplyMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NumClientsReplyMsg& default_instance();

  void Swap(NumClientsReplyMsg* other);

  // implements Message ----------------------------------------------

  inline NumClientsReplyMsg* New() const { return New(NULL); }

  NumClientsReplyMsg* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NumClientsReplyMsg& from);
  void MergeFrom(const NumClientsReplyMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NumClientsReplyMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .StreamClientsCount streamclients = 1;
  int streamclients_size() const;
  void clear_streamclients();
  static const int kStreamclientsFieldNumber = 1;
  const ::StreamClientsCount& streamclients(int index) const;
  ::StreamClientsCount* mutable_streamclients(int index);
  ::StreamClientsCount* add_streamclients();
  ::google::protobuf::RepeatedPtrField< ::StreamClientsCount >*
      mutable_streamclients();
  const ::google::protobuf::RepeatedPtrField< ::StreamClientsCount >&
      streamclients() const;

  // @@protoc_insertion_point(class_scope:NumClientsReplyMsg)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::StreamClientsCount > streamclients_;
  friend void  protobuf_AddDesc_IMSMessage_2eproto();
  friend void protobuf_AssignDesc_IMSMessage_2eproto();
  friend void protobuf_ShutdownFile_IMSMessage_2eproto();

  void InitAsDefaultInstance();
  static NumClientsReplyMsg* default_instance_;
};
// -------------------------------------------------------------------

class IMSMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IMSMessage) */ {
 public:
  IMSMessage();
  virtual ~IMSMessage();

  IMSMessage(const IMSMessage& from);

  inline IMSMessage& operator=(const IMSMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IMSMessage& default_instance();

  void Swap(IMSMessage* other);

  // implements Message ----------------------------------------------

  inline IMSMessage* New() const { return New(NULL); }

  IMSMessage* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IMSMessage& from);
  void MergeFrom(const IMSMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IMSMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 seqNo = 1;
  bool has_seqno() const;
  void clear_seqno();
  static const int kSeqNoFieldNumber = 1;
  ::google::protobuf::int64 seqno() const;
  void set_seqno(::google::protobuf::int64 value);

  // optional string cmd = 2;
  bool has_cmd() const;
  void clear_cmd();
  static const int kCmdFieldNumber = 2;
  const ::std::string& cmd() const;
  void set_cmd(const ::std::string& value);
  void set_cmd(const char* value);
  void set_cmd(const char* value, size_t size);
  ::std::string* mutable_cmd();
  ::std::string* release_cmd();
  void set_allocated_cmd(::std::string* cmd);

  // optional .AddStreamMsg addStream = 3;
  bool has_addstream() const;
  void clear_addstream();
  static const int kAddStreamFieldNumber = 3;
  const ::AddStreamMsg& addstream() const;
  ::AddStreamMsg* mutable_addstream();
  ::AddStreamMsg* release_addstream();
  void set_allocated_addstream(::AddStreamMsg* addstream);

  // optional .DelStreamMsg delStream = 4;
  bool has_delstream() const;
  void clear_delstream();
  static const int kDelStreamFieldNumber = 4;
  const ::DelStreamMsg& delstream() const;
  ::DelStreamMsg* mutable_delstream();
  ::DelStreamMsg* release_delstream();
  void set_allocated_delstream(::DelStreamMsg* delstream);

  // optional .StreamEndMsg streamEnd = 5;
  bool has_streamend() const;
  void clear_streamend();
  static const int kStreamEndFieldNumber = 5;
  const ::StreamEndMsg& streamend() const;
  ::StreamEndMsg* mutable_streamend();
  ::StreamEndMsg* release_streamend();
  void set_allocated_streamend(::StreamEndMsg* streamend);

  // optional .NumClientsReplyMsg NumClientsReplies = 6;
  bool has_numclientsreplies() const;
  void clear_numclientsreplies();
  static const int kNumClientsRepliesFieldNumber = 6;
  const ::NumClientsReplyMsg& numclientsreplies() const;
  ::NumClientsReplyMsg* mutable_numclientsreplies();
  ::NumClientsReplyMsg* release_numclientsreplies();
  void set_allocated_numclientsreplies(::NumClientsReplyMsg* numclientsreplies);

  // @@protoc_insertion_point(class_scope:IMSMessage)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_addstream();
  inline void clear_has_addstream();
  inline void set_has_delstream();
  inline void clear_has_delstream();
  inline void set_has_streamend();
  inline void clear_has_streamend();
  inline void set_has_numclientsreplies();
  inline void clear_has_numclientsreplies();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 seqno_;
  ::google::protobuf::internal::ArenaStringPtr cmd_;
  ::AddStreamMsg* addstream_;
  ::DelStreamMsg* delstream_;
  ::StreamEndMsg* streamend_;
  ::NumClientsReplyMsg* numclientsreplies_;
  friend void  protobuf_AddDesc_IMSMessage_2eproto();
  friend void protobuf_AssignDesc_IMSMessage_2eproto();
  friend void protobuf_ShutdownFile_IMSMessage_2eproto();

  void InitAsDefaultInstance();
  static IMSMessage* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// AddStreamMsg

// optional string streamId = 1;
inline bool AddStreamMsg::has_streamid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddStreamMsg::set_has_streamid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddStreamMsg::clear_has_streamid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddStreamMsg::clear_streamid() {
  streamid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_streamid();
}
inline const ::std::string& AddStreamMsg::streamid() const {
  // @@protoc_insertion_point(field_get:AddStreamMsg.streamId)
  return streamid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AddStreamMsg::set_streamid(const ::std::string& value) {
  set_has_streamid();
  streamid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AddStreamMsg.streamId)
}
inline void AddStreamMsg::set_streamid(const char* value) {
  set_has_streamid();
  streamid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AddStreamMsg.streamId)
}
inline void AddStreamMsg::set_streamid(const char* value, size_t size) {
  set_has_streamid();
  streamid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AddStreamMsg.streamId)
}
inline ::std::string* AddStreamMsg::mutable_streamid() {
  set_has_streamid();
  // @@protoc_insertion_point(field_mutable:AddStreamMsg.streamId)
  return streamid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AddStreamMsg::release_streamid() {
  // @@protoc_insertion_point(field_release:AddStreamMsg.streamId)
  clear_has_streamid();
  return streamid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AddStreamMsg::set_allocated_streamid(::std::string* streamid) {
  if (streamid != NULL) {
    set_has_streamid();
  } else {
    clear_has_streamid();
  }
  streamid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), streamid);
  // @@protoc_insertion_point(field_set_allocated:AddStreamMsg.streamId)
}

// repeated string rtmpSinkIP = 2;
inline int AddStreamMsg::rtmpsinkip_size() const {
  return rtmpsinkip_.size();
}
inline void AddStreamMsg::clear_rtmpsinkip() {
  rtmpsinkip_.Clear();
}
inline const ::std::string& AddStreamMsg::rtmpsinkip(int index) const {
  // @@protoc_insertion_point(field_get:AddStreamMsg.rtmpSinkIP)
  return rtmpsinkip_.Get(index);
}
inline ::std::string* AddStreamMsg::mutable_rtmpsinkip(int index) {
  // @@protoc_insertion_point(field_mutable:AddStreamMsg.rtmpSinkIP)
  return rtmpsinkip_.Mutable(index);
}
inline void AddStreamMsg::set_rtmpsinkip(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:AddStreamMsg.rtmpSinkIP)
  rtmpsinkip_.Mutable(index)->assign(value);
}
inline void AddStreamMsg::set_rtmpsinkip(int index, const char* value) {
  rtmpsinkip_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:AddStreamMsg.rtmpSinkIP)
}
inline void AddStreamMsg::set_rtmpsinkip(int index, const char* value, size_t size) {
  rtmpsinkip_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AddStreamMsg.rtmpSinkIP)
}
inline ::std::string* AddStreamMsg::add_rtmpsinkip() {
  // @@protoc_insertion_point(field_add_mutable:AddStreamMsg.rtmpSinkIP)
  return rtmpsinkip_.Add();
}
inline void AddStreamMsg::add_rtmpsinkip(const ::std::string& value) {
  rtmpsinkip_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:AddStreamMsg.rtmpSinkIP)
}
inline void AddStreamMsg::add_rtmpsinkip(const char* value) {
  rtmpsinkip_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:AddStreamMsg.rtmpSinkIP)
}
inline void AddStreamMsg::add_rtmpsinkip(const char* value, size_t size) {
  rtmpsinkip_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:AddStreamMsg.rtmpSinkIP)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AddStreamMsg::rtmpsinkip() const {
  // @@protoc_insertion_point(field_list:AddStreamMsg.rtmpSinkIP)
  return rtmpsinkip_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AddStreamMsg::mutable_rtmpsinkip() {
  // @@protoc_insertion_point(field_mutable_list:AddStreamMsg.rtmpSinkIP)
  return &rtmpsinkip_;
}

// -------------------------------------------------------------------

// DelStreamMsg

// optional string streamId = 1;
inline bool DelStreamMsg::has_streamid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DelStreamMsg::set_has_streamid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DelStreamMsg::clear_has_streamid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DelStreamMsg::clear_streamid() {
  streamid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_streamid();
}
inline const ::std::string& DelStreamMsg::streamid() const {
  // @@protoc_insertion_point(field_get:DelStreamMsg.streamId)
  return streamid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DelStreamMsg::set_streamid(const ::std::string& value) {
  set_has_streamid();
  streamid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DelStreamMsg.streamId)
}
inline void DelStreamMsg::set_streamid(const char* value) {
  set_has_streamid();
  streamid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DelStreamMsg.streamId)
}
inline void DelStreamMsg::set_streamid(const char* value, size_t size) {
  set_has_streamid();
  streamid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DelStreamMsg.streamId)
}
inline ::std::string* DelStreamMsg::mutable_streamid() {
  set_has_streamid();
  // @@protoc_insertion_point(field_mutable:DelStreamMsg.streamId)
  return streamid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DelStreamMsg::release_streamid() {
  // @@protoc_insertion_point(field_release:DelStreamMsg.streamId)
  clear_has_streamid();
  return streamid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DelStreamMsg::set_allocated_streamid(::std::string* streamid) {
  if (streamid != NULL) {
    set_has_streamid();
  } else {
    clear_has_streamid();
  }
  streamid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), streamid);
  // @@protoc_insertion_point(field_set_allocated:DelStreamMsg.streamId)
}

// -------------------------------------------------------------------

// StreamEndMsg

// optional string streamId = 1;
inline bool StreamEndMsg::has_streamid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StreamEndMsg::set_has_streamid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StreamEndMsg::clear_has_streamid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StreamEndMsg::clear_streamid() {
  streamid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_streamid();
}
inline const ::std::string& StreamEndMsg::streamid() const {
  // @@protoc_insertion_point(field_get:StreamEndMsg.streamId)
  return streamid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StreamEndMsg::set_streamid(const ::std::string& value) {
  set_has_streamid();
  streamid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:StreamEndMsg.streamId)
}
inline void StreamEndMsg::set_streamid(const char* value) {
  set_has_streamid();
  streamid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:StreamEndMsg.streamId)
}
inline void StreamEndMsg::set_streamid(const char* value, size_t size) {
  set_has_streamid();
  streamid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:StreamEndMsg.streamId)
}
inline ::std::string* StreamEndMsg::mutable_streamid() {
  set_has_streamid();
  // @@protoc_insertion_point(field_mutable:StreamEndMsg.streamId)
  return streamid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StreamEndMsg::release_streamid() {
  // @@protoc_insertion_point(field_release:StreamEndMsg.streamId)
  clear_has_streamid();
  return streamid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StreamEndMsg::set_allocated_streamid(::std::string* streamid) {
  if (streamid != NULL) {
    set_has_streamid();
  } else {
    clear_has_streamid();
  }
  streamid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), streamid);
  // @@protoc_insertion_point(field_set_allocated:StreamEndMsg.streamId)
}

// optional string rtmpSinkIP = 2;
inline bool StreamEndMsg::has_rtmpsinkip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StreamEndMsg::set_has_rtmpsinkip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StreamEndMsg::clear_has_rtmpsinkip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StreamEndMsg::clear_rtmpsinkip() {
  rtmpsinkip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_rtmpsinkip();
}
inline const ::std::string& StreamEndMsg::rtmpsinkip() const {
  // @@protoc_insertion_point(field_get:StreamEndMsg.rtmpSinkIP)
  return rtmpsinkip_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StreamEndMsg::set_rtmpsinkip(const ::std::string& value) {
  set_has_rtmpsinkip();
  rtmpsinkip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:StreamEndMsg.rtmpSinkIP)
}
inline void StreamEndMsg::set_rtmpsinkip(const char* value) {
  set_has_rtmpsinkip();
  rtmpsinkip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:StreamEndMsg.rtmpSinkIP)
}
inline void StreamEndMsg::set_rtmpsinkip(const char* value, size_t size) {
  set_has_rtmpsinkip();
  rtmpsinkip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:StreamEndMsg.rtmpSinkIP)
}
inline ::std::string* StreamEndMsg::mutable_rtmpsinkip() {
  set_has_rtmpsinkip();
  // @@protoc_insertion_point(field_mutable:StreamEndMsg.rtmpSinkIP)
  return rtmpsinkip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StreamEndMsg::release_rtmpsinkip() {
  // @@protoc_insertion_point(field_release:StreamEndMsg.rtmpSinkIP)
  clear_has_rtmpsinkip();
  return rtmpsinkip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StreamEndMsg::set_allocated_rtmpsinkip(::std::string* rtmpsinkip) {
  if (rtmpsinkip != NULL) {
    set_has_rtmpsinkip();
  } else {
    clear_has_rtmpsinkip();
  }
  rtmpsinkip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), rtmpsinkip);
  // @@protoc_insertion_point(field_set_allocated:StreamEndMsg.rtmpSinkIP)
}

// -------------------------------------------------------------------

// StreamClientsCount

// optional string streamId = 1;
inline bool StreamClientsCount::has_streamid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StreamClientsCount::set_has_streamid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StreamClientsCount::clear_has_streamid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StreamClientsCount::clear_streamid() {
  streamid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_streamid();
}
inline const ::std::string& StreamClientsCount::streamid() const {
  // @@protoc_insertion_point(field_get:StreamClientsCount.streamId)
  return streamid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StreamClientsCount::set_streamid(const ::std::string& value) {
  set_has_streamid();
  streamid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:StreamClientsCount.streamId)
}
inline void StreamClientsCount::set_streamid(const char* value) {
  set_has_streamid();
  streamid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:StreamClientsCount.streamId)
}
inline void StreamClientsCount::set_streamid(const char* value, size_t size) {
  set_has_streamid();
  streamid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:StreamClientsCount.streamId)
}
inline ::std::string* StreamClientsCount::mutable_streamid() {
  set_has_streamid();
  // @@protoc_insertion_point(field_mutable:StreamClientsCount.streamId)
  return streamid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StreamClientsCount::release_streamid() {
  // @@protoc_insertion_point(field_release:StreamClientsCount.streamId)
  clear_has_streamid();
  return streamid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StreamClientsCount::set_allocated_streamid(::std::string* streamid) {
  if (streamid != NULL) {
    set_has_streamid();
  } else {
    clear_has_streamid();
  }
  streamid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), streamid);
  // @@protoc_insertion_point(field_set_allocated:StreamClientsCount.streamId)
}

// optional int32 numClients = 2;
inline bool StreamClientsCount::has_numclients() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StreamClientsCount::set_has_numclients() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StreamClientsCount::clear_has_numclients() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StreamClientsCount::clear_numclients() {
  numclients_ = 0;
  clear_has_numclients();
}
inline ::google::protobuf::int32 StreamClientsCount::numclients() const {
  // @@protoc_insertion_point(field_get:StreamClientsCount.numClients)
  return numclients_;
}
inline void StreamClientsCount::set_numclients(::google::protobuf::int32 value) {
  set_has_numclients();
  numclients_ = value;
  // @@protoc_insertion_point(field_set:StreamClientsCount.numClients)
}

// -------------------------------------------------------------------

// NumClientsReplyMsg

// repeated .StreamClientsCount streamclients = 1;
inline int NumClientsReplyMsg::streamclients_size() const {
  return streamclients_.size();
}
inline void NumClientsReplyMsg::clear_streamclients() {
  streamclients_.Clear();
}
inline const ::StreamClientsCount& NumClientsReplyMsg::streamclients(int index) const {
  // @@protoc_insertion_point(field_get:NumClientsReplyMsg.streamclients)
  return streamclients_.Get(index);
}
inline ::StreamClientsCount* NumClientsReplyMsg::mutable_streamclients(int index) {
  // @@protoc_insertion_point(field_mutable:NumClientsReplyMsg.streamclients)
  return streamclients_.Mutable(index);
}
inline ::StreamClientsCount* NumClientsReplyMsg::add_streamclients() {
  // @@protoc_insertion_point(field_add:NumClientsReplyMsg.streamclients)
  return streamclients_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::StreamClientsCount >*
NumClientsReplyMsg::mutable_streamclients() {
  // @@protoc_insertion_point(field_mutable_list:NumClientsReplyMsg.streamclients)
  return &streamclients_;
}
inline const ::google::protobuf::RepeatedPtrField< ::StreamClientsCount >&
NumClientsReplyMsg::streamclients() const {
  // @@protoc_insertion_point(field_list:NumClientsReplyMsg.streamclients)
  return streamclients_;
}

// -------------------------------------------------------------------

// IMSMessage

// optional int64 seqNo = 1;
inline bool IMSMessage::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMSMessage::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMSMessage::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMSMessage::clear_seqno() {
  seqno_ = GOOGLE_LONGLONG(0);
  clear_has_seqno();
}
inline ::google::protobuf::int64 IMSMessage::seqno() const {
  // @@protoc_insertion_point(field_get:IMSMessage.seqNo)
  return seqno_;
}
inline void IMSMessage::set_seqno(::google::protobuf::int64 value) {
  set_has_seqno();
  seqno_ = value;
  // @@protoc_insertion_point(field_set:IMSMessage.seqNo)
}

// optional string cmd = 2;
inline bool IMSMessage::has_cmd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMSMessage::set_has_cmd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMSMessage::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMSMessage::clear_cmd() {
  cmd_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_cmd();
}
inline const ::std::string& IMSMessage::cmd() const {
  // @@protoc_insertion_point(field_get:IMSMessage.cmd)
  return cmd_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMSMessage::set_cmd(const ::std::string& value) {
  set_has_cmd();
  cmd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IMSMessage.cmd)
}
inline void IMSMessage::set_cmd(const char* value) {
  set_has_cmd();
  cmd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IMSMessage.cmd)
}
inline void IMSMessage::set_cmd(const char* value, size_t size) {
  set_has_cmd();
  cmd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IMSMessage.cmd)
}
inline ::std::string* IMSMessage::mutable_cmd() {
  set_has_cmd();
  // @@protoc_insertion_point(field_mutable:IMSMessage.cmd)
  return cmd_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IMSMessage::release_cmd() {
  // @@protoc_insertion_point(field_release:IMSMessage.cmd)
  clear_has_cmd();
  return cmd_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMSMessage::set_allocated_cmd(::std::string* cmd) {
  if (cmd != NULL) {
    set_has_cmd();
  } else {
    clear_has_cmd();
  }
  cmd_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cmd);
  // @@protoc_insertion_point(field_set_allocated:IMSMessage.cmd)
}

// optional .AddStreamMsg addStream = 3;
inline bool IMSMessage::has_addstream() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMSMessage::set_has_addstream() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMSMessage::clear_has_addstream() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMSMessage::clear_addstream() {
  if (addstream_ != NULL) addstream_->::AddStreamMsg::Clear();
  clear_has_addstream();
}
inline const ::AddStreamMsg& IMSMessage::addstream() const {
  // @@protoc_insertion_point(field_get:IMSMessage.addStream)
  return addstream_ != NULL ? *addstream_ : *default_instance_->addstream_;
}
inline ::AddStreamMsg* IMSMessage::mutable_addstream() {
  set_has_addstream();
  if (addstream_ == NULL) {
    addstream_ = new ::AddStreamMsg;
  }
  // @@protoc_insertion_point(field_mutable:IMSMessage.addStream)
  return addstream_;
}
inline ::AddStreamMsg* IMSMessage::release_addstream() {
  // @@protoc_insertion_point(field_release:IMSMessage.addStream)
  clear_has_addstream();
  ::AddStreamMsg* temp = addstream_;
  addstream_ = NULL;
  return temp;
}
inline void IMSMessage::set_allocated_addstream(::AddStreamMsg* addstream) {
  delete addstream_;
  addstream_ = addstream;
  if (addstream) {
    set_has_addstream();
  } else {
    clear_has_addstream();
  }
  // @@protoc_insertion_point(field_set_allocated:IMSMessage.addStream)
}

// optional .DelStreamMsg delStream = 4;
inline bool IMSMessage::has_delstream() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMSMessage::set_has_delstream() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMSMessage::clear_has_delstream() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMSMessage::clear_delstream() {
  if (delstream_ != NULL) delstream_->::DelStreamMsg::Clear();
  clear_has_delstream();
}
inline const ::DelStreamMsg& IMSMessage::delstream() const {
  // @@protoc_insertion_point(field_get:IMSMessage.delStream)
  return delstream_ != NULL ? *delstream_ : *default_instance_->delstream_;
}
inline ::DelStreamMsg* IMSMessage::mutable_delstream() {
  set_has_delstream();
  if (delstream_ == NULL) {
    delstream_ = new ::DelStreamMsg;
  }
  // @@protoc_insertion_point(field_mutable:IMSMessage.delStream)
  return delstream_;
}
inline ::DelStreamMsg* IMSMessage::release_delstream() {
  // @@protoc_insertion_point(field_release:IMSMessage.delStream)
  clear_has_delstream();
  ::DelStreamMsg* temp = delstream_;
  delstream_ = NULL;
  return temp;
}
inline void IMSMessage::set_allocated_delstream(::DelStreamMsg* delstream) {
  delete delstream_;
  delstream_ = delstream;
  if (delstream) {
    set_has_delstream();
  } else {
    clear_has_delstream();
  }
  // @@protoc_insertion_point(field_set_allocated:IMSMessage.delStream)
}

// optional .StreamEndMsg streamEnd = 5;
inline bool IMSMessage::has_streamend() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMSMessage::set_has_streamend() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMSMessage::clear_has_streamend() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMSMessage::clear_streamend() {
  if (streamend_ != NULL) streamend_->::StreamEndMsg::Clear();
  clear_has_streamend();
}
inline const ::StreamEndMsg& IMSMessage::streamend() const {
  // @@protoc_insertion_point(field_get:IMSMessage.streamEnd)
  return streamend_ != NULL ? *streamend_ : *default_instance_->streamend_;
}
inline ::StreamEndMsg* IMSMessage::mutable_streamend() {
  set_has_streamend();
  if (streamend_ == NULL) {
    streamend_ = new ::StreamEndMsg;
  }
  // @@protoc_insertion_point(field_mutable:IMSMessage.streamEnd)
  return streamend_;
}
inline ::StreamEndMsg* IMSMessage::release_streamend() {
  // @@protoc_insertion_point(field_release:IMSMessage.streamEnd)
  clear_has_streamend();
  ::StreamEndMsg* temp = streamend_;
  streamend_ = NULL;
  return temp;
}
inline void IMSMessage::set_allocated_streamend(::StreamEndMsg* streamend) {
  delete streamend_;
  streamend_ = streamend;
  if (streamend) {
    set_has_streamend();
  } else {
    clear_has_streamend();
  }
  // @@protoc_insertion_point(field_set_allocated:IMSMessage.streamEnd)
}

// optional .NumClientsReplyMsg NumClientsReplies = 6;
inline bool IMSMessage::has_numclientsreplies() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IMSMessage::set_has_numclientsreplies() {
  _has_bits_[0] |= 0x00000020u;
}
inline void IMSMessage::clear_has_numclientsreplies() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void IMSMessage::clear_numclientsreplies() {
  if (numclientsreplies_ != NULL) numclientsreplies_->::NumClientsReplyMsg::Clear();
  clear_has_numclientsreplies();
}
inline const ::NumClientsReplyMsg& IMSMessage::numclientsreplies() const {
  // @@protoc_insertion_point(field_get:IMSMessage.NumClientsReplies)
  return numclientsreplies_ != NULL ? *numclientsreplies_ : *default_instance_->numclientsreplies_;
}
inline ::NumClientsReplyMsg* IMSMessage::mutable_numclientsreplies() {
  set_has_numclientsreplies();
  if (numclientsreplies_ == NULL) {
    numclientsreplies_ = new ::NumClientsReplyMsg;
  }
  // @@protoc_insertion_point(field_mutable:IMSMessage.NumClientsReplies)
  return numclientsreplies_;
}
inline ::NumClientsReplyMsg* IMSMessage::release_numclientsreplies() {
  // @@protoc_insertion_point(field_release:IMSMessage.NumClientsReplies)
  clear_has_numclientsreplies();
  ::NumClientsReplyMsg* temp = numclientsreplies_;
  numclientsreplies_ = NULL;
  return temp;
}
inline void IMSMessage::set_allocated_numclientsreplies(::NumClientsReplyMsg* numclientsreplies) {
  delete numclientsreplies_;
  numclientsreplies_ = numclientsreplies;
  if (numclientsreplies) {
    set_has_numclientsreplies();
  } else {
    clear_has_numclientsreplies();
  }
  // @@protoc_insertion_point(field_set_allocated:IMSMessage.NumClientsReplies)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_IMSMessage_2eproto__INCLUDED
